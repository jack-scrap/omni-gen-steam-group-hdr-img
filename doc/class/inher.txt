"Inheritance" describes the process using processes to create other classes.

Doing so can effectively describe complex sets of data without re-using code.

General groups can be composed from which more specific ones can be created.

# Creating
The name of the parent class provided between will inherit all properties.

```
class Parent:
	var = 3

	def fn():
		print("Text")

class Child(Parent):
	...
```

Here, the properties have been automatically added to the class `Child`.

## Multi-level
Multiple levels of inheritence can exist, and objects will continually inherit.

```
class GrandParent:
	var = 3

	def fn():
		print("Text")

class Parent(GrandParent):
	other_var = 3

class Child(Parent):
	...
```

## Multiple
	A child class can inherit from more than one parent.

```
class Parent:
	var = 3

	def fn():
		print("Text")

class OtherParent:
	other_var = 3

	def other_fn():
		print("Text")

class Child(Parent, OtherParent):
	...
```

The class `Child` contains all of the attributes of `GrandParent` and `Parent`.

## Duplicate names
The possibility exists that identifiers across classes may share a name.

In the case that multiple of these classes are used to create a new one, the first class provided will be searched, with the rest following should it not be found.

```
class Parent:
	var = 3

class OtherParent:
	var = 7

class Child(Parent, OtherParent):
	...
```

The value of `var` resolves to the first variable, `3`.

```
class Parent:
	var = 3

class OtherParent:
	other_var = 7

class Child(Parent, OtherParent):
	...
```

Having no duplicate variable names, the value of `var` resolves to `7`.

## Overriding
Overriding will discard the parent and substitute it with one provided by the child.

```
TODO
```

## Overloading

```
TODO
```

## Accessing parents
Like the `self` variable assigned within classes, `super` can be used to access the parent.

```
class Parent:
	var = 3

class Child(Parent):
	print(super.var)
```

## Class methods
This allows for scoping of functions to a specific location.

`self` now refers to the class instead of the object.

```
class Parent:
	@classmethod
	def fn(self):
  	print('Text')
```

## Static methods
Static functions are simply functions created to be scoped to a specific location.

No knowledge of the class or object exist.

```
class Class:
	@staticmethod
	def fn():
		print('Text')

Class.fn()
```
