# Classes
Classes are templates for creating objects.

This can be used to effectively create a new type.

The following defines a class.

```
class Blueprint:
		...
```

The following creates an object that adheres to that class.

```
class Blueprint:
	...

obj = Blueprint()
```

## Constructor
The "constructor" is a function of special usage that runs on creation of an object.

It is defined as `__init__`, taking exactly one variable of the name `self` that is automatically provided.

The return value is the newly created object.

```
class Blueprint:
	...

obj = Blueprint()
```

This function is created implicitly, and does not need to be defined should it work the same.

### Custom constructor
Instead of the default constructor, one can be defined.

```
class Blueprint:
	def __init__(self):
		print('Text')
	
obj = Blueprint()
```

Custom arguments may be provided.

```
class Blueprint:
	def __init__(self, arg):
		print(arg)
```

## Methods
"Methods" are functions scoped to an object.

Defining methods simply requires writing them in the function body.

```
class Parent:
	def fn(self):
		print('Text')
```

## Local variables
Variables local to a function must be defined in the constructor.

Doing so requires usage of the `self` variable.

### self
This `self` variable describes object being created.

Setting of these attributes will

```
class Parent:
	var = 3

obj = Parent()

print(obj.var)
```

# Private
Should variables and functions strictly be desired to be used within the class, names can be marked as such.

Prefixing names with double underscores (`__`) will only make these declarations visible within the class itself.

```
class Blueprint:
	__var = 3

	__fn():
		print("Text")
```

These names may be accessed within the scope of the class.
However, attempting access them outside of the class will not match the identifier.

The following is valid.

```
class Blueprint:
	...

	def other_fn():
		__fn()
```

The following is not.

```
...

obj = Blueprint()

obj.__fn()
```

# Class methods
It is not necessary for classes to create objects.

"Class methods" describe the process of simply creating functions within the scope of a class definition.

```
class Group:
	var = 3

	@classmethod
	def hjkl(self):
		print(self.var)
```

# Static methods
Static methods take the concept of class methods one step further.

Variables and functions can be defined within a class definition, w

```
class Group:
	var = 3
```

This simply scopes the defined va

Accessing works the same as it would on an object.

```
print(Group.var)
```

## Methods
Defining and utilizing functions where an object is not present works slightly differently.

The `staticmethod` decorator must be provided proceeding the function.

```
class Group:
	@staticmethod
	def fn():
		print('Text')
```

Note the lack of a `self` argument to refer an object that would be present.

Accessing works the same.

```
Group.fn()
```

# Getters and setters
The convention of "getters and getters" describe members created explicitly for the purpose of interacting with the class's attributes.

Doing so allows a class to strictly operate on itself, with no interaction with the outside necessary.

Getter:
```
class Blueprint:
	var = 3

  def getVar(self):
		return self.var
```

Setter:
```
class Blueprint:
	var = 3

  def setVar(self, var):
		self.var = var
```

## Decorator
As of Python 3, special syntax exists to implement the functionality of getters and setters more inherently.

The `property` decorator can be applied to functions to replace the default operations undergone when accessing and editing data.

### Getter
Providing `@property` above the name of a function that returns an attribute signifies it as a getter.

Note that the function name must be separate from the variable.

```
@property
def var(self):
		return self._var
```

Calling:
```
obj = Blueprint()

var = obj.var
```

On accessing this property, this getter will be called.

This can be verified by adding additional functionality to the getter, and observing how the statements are called.

```
...
@property
def var(self):
	print('Text')

	return self._var

var = obj._var
```

### Setter
The following declares a setter.

```
@var.setter
def var(self, var):
		self._var = var
```
